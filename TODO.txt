TODO

Attribute can only be viewed using python when in Object Mode:
bpy.data.meshes['bouncer_1'].attributes['jbeam_node_id'].data[0].value

To view Attributes in Edit Mode:

import bmesh
bm = bmesh.from_edit_mesh(bpy.context.object.data)
v = bm.verts[0]
layer = bm.verts.layers.string.get("jbeam_node_id")
value = v[layer]
v[layer] = f"<new-value>".encode("utf-8")



import bpy
import bmesh


class VertexMonitorOperator(bpy.types.Operator):
    bl_idname = "wm.vertex_monitor"
    bl_label = "Vertex Monitor"
    bl_description = "Monitor selected vertices and update JBeam Node IDs"
    
    _timer = None
    _last_selected_indices = set()
    
    def modal(self, context, event):
        obj = context.object
        if not obj or obj.type != 'MESH' or obj.mode != 'EDIT':
            return {'PASS_THROUGH'}

        if "jbeam_node_id" not in obj.data.attributes:
            return {'PASS_THROUGH'}  # Ignore non-JBeam objects

        if event.type == 'TIMER':
            self.update_vertex_data(context)
        return {'PASS_THROUGH'}
    
    def execute(self, context):
        wm = context.window_manager
        self._timer = wm.event_timer_add(0.1, window=context.window)
        wm.modal_handler_add(self)
        return {'RUNNING_MODAL'}
    
    def force_update_ui(self):
        for area in bpy.context.screen.areas:
            if area.type in {'PROPERTIES', 'VIEW_3D'}:
                for region in area.regions:
                    if region.type in {'WINDOW', 'UI'}:
                        region.tag_redraw()
    
    def update_vertex_data(self, context):
        obj = context.object
        if obj is None or obj.type != 'MESH' or obj.mode != 'EDIT':
            return
        
        bm = bmesh.from_edit_mesh(obj.data)
        bm.verts.ensure_lookup_table()
        selected_verts = [v.index for v in bm.verts if v.select]

        if not selected_verts:
            if self._last_selected_indices:  # Only update if we had a previous selection
                self._last_selected_indices.clear()
                context.scene.active_vertex_idx = -1
                context.scene.jbeam_node_id = ""
                
                self.force_update_ui()
                return
                
        
        # Get active vertex if possible
        active_vert = bm.select_history.active if isinstance(bm.select_history.active, bmesh.types.BMVert) else None
        active_index = active_vert.index if active_vert else (selected_verts[-1] if selected_verts else -1)


        # Only update UI if selection changed
        if set(selected_verts) != self._last_selected_indices:
            self._last_selected_indices = set(selected_verts)
            context.scene.active_vertex_idx = active_index  # Display the active vertex
            
            # Get JBeam IDs for all selected vertices
            layer = bm.verts.layers.string.get("jbeam_node_id")
            if layer:
                jbeam_ids = [bm.verts[v_idx][layer].decode("utf-8") for v_idx in selected_verts if bm.verts[v_idx][layer]]
                context.scene.jbeam_node_id = ", ".join(jbeam_ids)
            else:
                context.scene.jbeam_node_id = ""
            
            self.force_update_ui()
    

class AssignJBeamIDOperator(bpy.types.Operator):
    """Assigns a new JBeam Node ID to the selected vertex"""
    bl_idname = "object.assign_jbeam_id"
    bl_label = "Assign JBeam ID"

    def execute(self, context):
        obj = context.object
        if obj is None or obj.type != 'MESH':
            self.report({'WARNING'}, "No valid mesh object selected")
            return {'CANCELLED'}

        mesh = obj.data
        index = context.scene.active_vertex_idx
        new_value = context.scene.jbeam_node_id.encode("utf-8")

        if obj.mode == 'EDIT':
            bm = bmesh.from_edit_mesh(mesh)
            layer = bm.verts.layers.string.get("jbeam_node_id")
            bm.verts[index][layer] = new_value
            bmesh.update_edit_mesh(mesh)

        self.report({'INFO'}, f"Assigned JBeam Node ID: {context.scene.jbeam_node_id}")
        return {'FINISHED'}

class VertexJBeamEditorPanel(bpy.types.Panel):
    bl_label = "Vertex JBeam Editor"
    bl_idname = "VIEW3D_PT_vertex_jbeam_editor"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = "Tool"

    def draw(self, context):
        layout = self.layout
        scene = context.scene

        layout.operator("wm.vertex_monitor", text="Start Selection Watcher")

        obj = context.object
        mesh = obj.data

        if obj and obj.mode == 'EDIT' and obj.type == 'MESH' and "jbeam_node_id" in obj.data.attributes:
            bm = bmesh.from_edit_mesh(mesh)
            layer = bm.verts.layers.string.get("jbeam_node_id")
            index = scene.active_vertex_idx
            active_node_id = bm.verts[index][layer].decode("utf-8")
            layout.label(text=f"Active Node: {active_node_id} ({index})")
            layout.prop(scene, "jbeam_node_id", text="JBeam Node ID")
            layout.operator("object.assign_jbeam_id", text="Assign JBeam ID")


def register():
    bpy.utils.register_class(VertexMonitorOperator)
    bpy.utils.register_class(VertexJBeamEditorPanel)
    bpy.utils.register_class(AssignJBeamIDOperator)
    bpy.types.Scene.active_vertex_idx = bpy.props.IntProperty(name="Vertex Index", default=-1)
    bpy.types.Scene.jbeam_node_id = bpy.props.StringProperty(name="JBeam Node ID")

def unregister():
    bpy.utils.unregister_class(VertexMonitorOperator)
    bpy.utils.unregister_class(VertexJBeamEditorPanel)
    bpy.utils.unregister_class(AssignJBeamIDOperator)
    del bpy.types.Scene.active_vertex_idx
    del bpy.types.Scene.jbeam_node_id

if __name__ == "__main__":
    register()


==========================================================================

import bpy
import bmesh
import json

class JBeamPropertyItem(bpy.types.PropertyGroup):
    name: bpy.props.StringProperty(name="Property Name")
    value: bpy.props.StringProperty(name="Value")


class VertexJBeamPropertiesPanel(bpy.types.Panel):
    bl_label = "JBeam Vertex Properties"
    bl_idname = "VIEW3D_PT_jbeam_vertex_props"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = "Tool"

    def draw(self, context):
        layout = self.layout
        scene = context.scene
        obj = context.object

        if not obj or obj.type != 'MESH' or obj.mode != 'EDIT':
            layout.label(text="Select a mesh in Edit Mode")
            return

        # Button to load properties
        layout.operator("object.load_jbeam_props", text="Load Properties")

        for prop in scene.jbeam_vertex_props:
            row = layout.row()
            row.prop(prop, "name", text="")
            row.prop(prop, "value", text="")
            row.operator("object.save_jbeam_prop", text="S").prop_name = prop.name
            row.operator("object.remove_jbeam_prop", text="X").prop_name = prop.name

        # Add new property button
        layout.operator("object.add_jbeam_prop", text="Add Property")

        # Save All Button
        layout.operator("object.save_all_jbeam_props", text="Save All")


class LoadJBeamPropsOperator(bpy.types.Operator):
    """Load JBeam properties of the selected vertex"""
    bl_idname = "object.load_jbeam_props"
    bl_label = "Load JBeam Properties"

    def execute(self, context):
        obj = context.object
        if not obj or obj.type != 'MESH':
            self.report({'WARNING'}, "No valid mesh object selected")
            return {'CANCELLED'}

        bm = bmesh.from_edit_mesh(obj.data)
        layer = bm.verts.layers.string.get("jbeam_node_props")
        selected_verts = [v for v in bm.verts if v.select]

        if not selected_verts or not layer:
            self.report({'WARNING'}, "No selected vertices or no property data found")
            return {'CANCELLED'}

        context.scene.jbeam_vertex_props.clear()
        properties = {}

        for v in selected_verts:
            try:
                props = json.loads(v[layer].decode("utf-8")) if v[layer] else {}
                for key, value in props.items():
                    properties[key] = value
            except Exception as e:
                self.report({'ERROR'}, f"Failed to load properties: {e}")

        for key, value in properties.items():
            prop = context.scene.jbeam_vertex_props.add()
            prop.name = key
            prop.value = str(value)

        return {'FINISHED'}


class SaveJBeamPropOperator(bpy.types.Operator):
    """Save a single JBeam property"""
    bl_idname = "object.save_jbeam_prop"
    bl_label = "Save JBeam Property"

    prop_name: bpy.props.StringProperty()

    def execute(self, context):
        obj = context.object
        if not obj or obj.type != 'MESH':
            self.report({'WARNING'}, "No valid mesh object selected")
            return {'CANCELLED'}

        bm = bmesh.from_edit_mesh(obj.data)
        layer = bm.verts.layers.string.get("jbeam_node_props")
        selected_verts = [v for v in bm.verts if v.select]

        if not selected_verts or not layer:
            self.report({'WARNING'}, "No selected vertices or no property data found")
            return {'CANCELLED'}

        for v in selected_verts:
            try:
                props = json.loads(v[layer].decode("utf-8")) if v[layer] else {}
                for prop in context.scene.jbeam_vertex_props:
                    if prop.name == self.prop_name:
                        props[prop.name] = prop.value
                        break
                v[layer] = json.dumps(props).encode("utf-8")
            except Exception as e:
                self.report({'ERROR'}, f"Failed to save property: {e}")

        bmesh.update_edit_mesh(obj.data)
        self.report({'INFO'}, f"Saved property: {self.prop_name}")
        return {'FINISHED'}


class SaveAllJBeamPropsOperator(bpy.types.Operator):
    """Save all JBeam properties"""
    bl_idname = "object.save_all_jbeam_props"
    bl_label = "Save All JBeam Properties"

    def execute(self, context):
        obj = context.object
        if not obj or obj.type != 'MESH':
            self.report({'WARNING'}, "No valid mesh object selected")
            return {'CANCELLED'}

        bm = bmesh.from_edit_mesh(obj.data)
        layer = bm.verts.layers.string.get("jbeam_node_props")
        selected_verts = [v for v in bm.verts if v.select]

        if not selected_verts or not layer:
            self.report({'WARNING'}, "No selected vertices or no property data found")
            return {'CANCELLED'}

        # Get current properties in the UI
        ui_props = {prop.name: prop.value for prop in context.scene.jbeam_vertex_props}

        for v in selected_verts:
            try:
                props = json.loads(v[layer].decode("utf-8")) if v[layer] else {}

                # Remove properties that are missing from the UI
                props = {k: v for k, v in props.items() if k in ui_props}

                # Update values from the UI
                for prop_name, prop_value in ui_props.items():
                    props[prop_name] = prop_value

                v[layer] = json.dumps(props).encode("utf-8")

            except Exception as e:
                self.report({'ERROR'}, f"Failed to save properties: {e}")

        bmesh.update_edit_mesh(obj.data)
        self.report({'INFO'}, "Saved all properties")
        return {'FINISHED'}



class AddJBeamPropOperator(bpy.types.Operator):
    """Add a new JBeam property"""
    bl_idname = "object.add_jbeam_prop"
    bl_label = "Add JBeam Property"

    def execute(self, context):
        prop = context.scene.jbeam_vertex_props.add()
        prop.name = "NewProp"
        prop.value = "0"
        return {'FINISHED'}


class RemoveJBeamPropOperator(bpy.types.Operator):
    """Remove a JBeam property"""
    bl_idname = "object.remove_jbeam_prop"
    bl_label = "Remove JBeam Property"

    prop_name: bpy.props.StringProperty()

    def execute(self, context):
        scene = context.scene
        for i, prop in enumerate(scene.jbeam_vertex_props):
            if prop.name == self.prop_name:
                scene.jbeam_vertex_props.remove(i)
                break
        return {'FINISHED'}


def register():
    bpy.utils.register_class(JBeamPropertyItem)
    bpy.utils.register_class(VertexJBeamPropertiesPanel)
    bpy.utils.register_class(LoadJBeamPropsOperator)
    bpy.utils.register_class(SaveJBeamPropOperator)
    bpy.utils.register_class(SaveAllJBeamPropsOperator)
    bpy.utils.register_class(AddJBeamPropOperator)
    bpy.utils.register_class(RemoveJBeamPropOperator)

    bpy.types.Scene.jbeam_vertex_props = bpy.props.CollectionProperty(type=JBeamPropertyItem)


def unregister():
    bpy.utils.unregister_class(JBeamPropertyItem)
    bpy.utils.unregister_class(VertexJBeamPropertiesPanel)
    bpy.utils.unregister_class(LoadJBeamPropsOperator)
    bpy.utils.unregister_class(SaveJBeamPropOperator)
    bpy.utils.unregister_class(SaveAllJBeamPropsOperator)
    bpy.utils.unregister_class(AddJBeamPropOperator)
    bpy.utils.unregister_class(RemoveJBeamPropOperator)

    del bpy.types.Scene.jbeam_vertex_props


if __name__ == "__main__":
    register()
