TODO

Attribute can only be viewed using python when in Object Mode:
node_id = obj.data.attributes['jbeam_node_id'].data[vertex_index].value.decode(utf8)

To view Attributes in Edit Mode:

import bmesh
bm = bmesh.from_edit_mesh(bpy.context.object.data)
v = bm.verts[0]
layer = bm.verts.layers.string.get("jbeam_node_id")
value = v[layer]
v[layer] = f"<new-value>".encode("utf-8")



'''
I have a script that generates a structured list of nodes and their properties, making it easier to merge and propagate attributes upward in the hierarchy. The goal is to transform this data into a valid JBeam format while minimizing redundancy. Since JBeam is designed to reduce duplicate property definitions:
'''

import bpy
import json
from collections import OrderedDict

DEFAULT_SCOPE_MODIFIER_VALUES = {
    "frictionCoef": "1.0",
    "nodeMaterial": "|NM_METAL",
    "nodeWeight": "25",
    "collision": "true",
    "selfCollision": "false",
    "fixed": "false",
    "group": "",
    "disable": "",
    "beamPrecompression": "1",
    "beamType": "|NORMAL",
    "beamLongBound": "1",
    "beamShortBound": "1",
    "beamSpring": "10000000",
    "beamDamp": "0",
    "beamDeform": "FLT_MAX",
    "beamStrength": "FLT_MAX",
    "breakGroup": "",
    "groundModel": "asphalt"
}

def get_vertex_groups(obj):
    return {vg.index: vg.name for vg in obj.vertex_groups if vg.name.startswith("group_")}

def get_vertex_group_memberships(obj, vertex_groups):
    return {
        v.index: sorted([vertex_groups[g.group] for g in v.groups if g.group in vertex_groups])
        for v in obj.data.vertices
    }

def get_node_properties(obj):
    attr = obj.data.attributes.get("jbeam_node_props")
    if attr:
        return {i: attr.data[i].value.decode("utf-8") for i in range(len(attr.data))}
    return {}

def parse_properties(properties_str):
    if not properties_str:
        return {}
    return {
        k.strip(): v.strip()
        for item in properties_str.strip("{}").replace('"', '').split(",")
        if (parts := item.split(":", 1)) and len(parts) == 2
        for k, v in [parts]
    }

def structure_vertex_data(obj):
    vertex_groups = get_vertex_groups(obj)
    vertex_to_groups = get_vertex_group_memberships(obj, vertex_groups)
    node_props = get_node_properties(obj)

    node_data_dict = {
        obj.data.attributes["jbeam_node_id"].data[v_idx].value.decode("utf-8"): {
            "group": groups,
            **parse_properties(node_props.get(v_idx, "")),
        }
        for v_idx, groups in vertex_to_groups.items()
    }

    sorted_nodes = sorted(node_data_dict.items(), key=lambda x: (not x[1]["group"], x[0].lower()))

    unique_props = set()  # Collect all unique properties dynamically

    # First pass: Find all unique properties
    for node_info in node_data_dict.values():
        unique_props.update(node_info.keys())

    # Second pass: Ensure each node only has missing properties filled
    final_node_list = {}
    for node_id, node_info in sorted_nodes:
        cleaned_node_info = {k.strip(): v for k, v in node_info.items()}

        # Add only missing properties
        for prop in unique_props:
            if prop not in cleaned_node_info:
                cleaned_node_info[prop] = DEFAULT_SCOPE_MODIFIER_VALUES.get(prop, "")

        # Ensure group is first, rest sorted alphabetically
        sorted_props = {"group": cleaned_node_info.pop("group")}
        sorted_props.update(dict(sorted(cleaned_node_info.items(), key=lambda x: x[0].lower())))

        formatted_props = ", ".join(
            f'"{k}": {json.dumps(v) if isinstance(v, (list, bool, int, float)) else json.dumps(str(v).strip())}'
            for k, v in sorted_props.items()
        )

        final_node_list[node_id] = f"{{{formatted_props}}}"

    # Sort first by 'group' length, then by group name, and then by all other properties' order
    data_sorted = dict(sorted(final_node_list.items(), key=lambda x: (
        -len(json.loads(x[1])['group']), 
        json.loads(x[1])['group'],
        tuple(json.loads(x[1]).get(prop, "") for prop in unique_props)  # Sub-sort by the values of all properties in order
    )))

    print("\n\n")
    for key, value in data_sorted.items():
        print(f"{key}: {value}")

    print("\nðŸ”¹ Unique Properties Used:\n", sorted(unique_props))


structure_vertex_data(bpy.context.object)


'''
This script currently outputs something that looks like this:

data = {
    "b5": {"group": ["group_bouncer_base", "group_bouncer_spring"], "collision": "false", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_RUBBER", "nodeWeight": "1.3", "selfCollision": "true"},
    "b9": {"group": ["group_bouncer_base", "group_bouncer_spring"], "collision": "false", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_RUBBER", "nodeWeight": "1.3", "selfCollision": "true"},
    "b1": {"group": ["group_bouncer_base", "group_bouncer_spring"], "collision": "false", "fixed": "true", "frictionCoef": "1.2", "nodeMaterial": "|NM_RUBBER", "nodeWeight": "2.3", "selfCollision": "true"},
    "b8": {"group": ["group_bouncer_base", "group_bouncer_spring"], "collision": "false", "fixed": "true", "frictionCoef": "1.2", "nodeMaterial": "|NM_RUBBER", "nodeWeight": "2.3", "selfCollision": "true"},
    "b2": {"group": ["group_bouncer_spring", "group_bouncer_top"], "collision": "false", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_PLASTIC", "nodeWeight": "2.3", "selfCollision": "false"},
    "b6": {"group": ["group_bouncer_spring", "group_bouncer_top"], "collision": "false", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_RUBBER", "nodeWeight": "2.3", "selfCollision": "false"},
    "b4": {"group": ["group_bouncer_spring", "group_bouncer_top"], "collision": "false", "fixed": "true", "frictionCoef": "1.2", "nodeMaterial": "|NM_RUBBER", "nodeWeight": "2.3", "selfCollision": "false"},
    "b3": {"group": ["group_bouncer_spring", "group_bouncer_top"], "collision": "true", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_RUBBER", "nodeWeight": "3.5", "selfCollision": "false"},
    "b14": {"group": ["group_bouncer_base"], "collision": "false", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_PLASTIC", "nodeWeight": "3.5", "selfCollision": "false"},
    "b13": {"group": ["group_bouncer_base"], "collision": "true", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_PLASTIC", "nodeWeight": "3.5", "selfCollision": "false"},
    "b12": {"group": ["group_bouncer_base"], "collision": "true", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_RUBBER", "nodeWeight": "3.5", "selfCollision": "false"},
    "b15": {"group": ["group_bouncer_base"], "collision": "true", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_RUBBER", "nodeWeight": "3.5", "selfCollision": "false"},
    "b11": {"group": ["group_bouncer_spring"], "collision": "false", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_PLASTIC", "nodeWeight": "3.5", "selfCollision": "false"},
    "b19": {"group": ["group_bouncer_top"], "collision": "false", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_PLASTIC", "nodeWeight": "3.5", "selfCollision": "false"},
    "b17": {"group": ["group_bouncer_top"], "collision": "false", "fixed": "true", "frictionCoef": "1.2", "nodeMaterial": "|NM_PLASTIC", "nodeWeight": "6.3", "selfCollision": "false"},
    "b16": {"group": ["group_bouncer_top"], "collision": "false", "fixed": "true", "frictionCoef": "1.2", "nodeMaterial": "|NM_PLASTIC", "nodeWeight": "10", "selfCollision": "true"},
    "b18": {"group": ["group_bouncer_top"], "collision": "false", "fixed": "true", "frictionCoef": "1.2", "nodeMaterial": "|NM_PLASTIC", "nodeWeight": "10", "selfCollision": "true"},
    "b7": {"group": [], "collision": "false", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_PLASTIC", "nodeWeight": "10", "selfCollision": "true"},
    "b10": {"group": [], "collision": "false", "fixed": "true", "frictionCoef": "1.2", "nodeMaterial": "|NM_PLASTIC", "nodeWeight": "10", "selfCollision": "true"},
    "ref": {"group": [], "collision": "false", "fixed": "true", "frictionCoef": "1.2", "nodeMaterial": "|NM_PLASTIC", "nodeWeight": "10", "selfCollision": "true"},
}


 # RESTRUCTURED:

m1 = "collision":false
m2 = "collision":true
m3 = "fixed":true
m4 = "fixed":false
m5 = "frictionCoef":1.2
m6 = "nodeMaterial":"|NM_RUBBER"
m7 = "nodeMaterial":"|NM_PLASTIC"
m8 = "nodeWeight":3.5
m9 = "nodeWeight":2.3
m10 = "selfCollision":true
m11 = "selfCollision":false
m12 = "nodeWeight":10
m13 = "nodeWeight":1.3
m14 = "nodeWeight": "6.3"
m## ... etc there can be any amount of properties


"b1" => {"group": ["group_bouncer_base", "group_bouncer_spring"], m1, m3, m5, m6, m9, m10}
"b11" => {"group": ["group_bouncer_spring"], m1, m4, m5, m7, m8, m11}
"b12" => {"group": ["group_bouncer_base"], m2, m4, m5, m6, m8, m11}
"b13" => {"group": ["group_bouncer_base"], m2, m4, m5, m7, m8, m11}
"b14" => {"group": ["group_bouncer_base"], m1, m4, m5, m7, m8, m11}
"b15" => {"group": ["group_bouncer_base"], m2, m4, m5, m6, m8, m11}
"b16" => {"group": ["group_bouncer_top"], m1, m3, m5, m7, m12, m10}
"b17" => {"group": ["group_bouncer_top"], m1, m3, m5, m7, m14, m11}
"b18" => {"group": ["group_bouncer_top"], m1, m3, m5, m7, m12, m10}
"b19" => {"group": ["group_bouncer_top"], m1, m4, m5, m7, m8, m11}
"b2" => {"group": ["group_bouncer_spring", "group_bouncer_top"], m1, m4, m5, m7, m9, m11}
"b3" => {"group": ["group_bouncer_spring", "group_bouncer_top"], m2, m4, m5, m6, m8, m11}
"b4" => {"group": ["group_bouncer_spring", "group_bouncer_top"], m1, m3, m5, m6, m9, m11}
"b5" => {"group": ["group_bouncer_base", "group_bouncer_spring"], m1, m4, m5, m6, m13, m10}
"b6" => {"group": ["group_bouncer_spring", "group_bouncer_top"], m1, m4, m5, m6, m9, m11}
"b8" => {"group": ["group_bouncer_base", "group_bouncer_spring"], m1, m3, m5, m6, m9, m10}
"b9" => {"group": ["group_bouncer_base", "group_bouncer_spring"], m1, m4, m5, m6, m13, m10}
"b10" => {"group": [], m1, m3, m5, m7, m12, m10}
"b7" => {"group": [], m1, m4, m5, m7, m12, m10}
"ref" => {"group": [], m1, m3, m5, m7, m12, m10}


{"group":["group_bouncer_base","group_bouncer_spring"]},
{m5},
{m6},
{m13},
{m1},
{m10},
["b5"],
{m1},
["b9"],
{m3},
{m9},
["b8"],
["b1"],
{"group":["group_bouncer_spring","group_bouncer_top"]},
{m11},
["b4"],
{"fixed":false},
["b6"],
{m7},
["b2"],
{m8},
{m6},
{m2},
["b3"],
{"group":"group_bouncer_base"},
["b12"],
["b15"],
["b13"],
{m1},
["b14"],
{"group":"group_bouncer_spring"},
["b11"],
{"group":"group_bouncer_top"},
["b19"],
{"nodeWeight":6.3},
{m3},
["b17"],
{m12},
{m10},
["b16"],
["b18"],
{"group":""},
["ref"],
{m3},
["b10"],
{m4},
["b7"],


{"group":["group_bouncer_base","group_bouncer_spring"]},
{"frictionCoef":1.2},
{"nodeMaterial":"|NM_RUBBER"},
{"nodeWeight":1.3},
{"collision":false},
{"selfCollision":true},
["b5"],
{"collision":false},
["b9"],
{"fixed":true},
{"nodeWeight":2.3},
["b8"],
["b1"],
{"group":["group_bouncer_spring","group_bouncer_top"]},
{"selfCollision":false},
["b4"],
{"fixed":false},
["b6"],
{"nodeMaterial":"|NM_PLASTIC"},
["b2"],
{"nodeWeight":3.5},
{"nodeMaterial":"|NM_RUBBER"},
{"collision":true},
["b3"],
{"group":"group_bouncer_base"},
["b12"],
["b15"],
{"nodeMaterial":"|NM_PLASTIC"},
["b13"],
{"collision":false},
["b14"],
{"group":"group_bouncer_spring"},
["b11"],
{"group":"group_bouncer_top"},
["b19"],
{"nodeWeight":6.3},
{"fixed":true},
["b17"],
{"nodeWeight":10},
{"selfCollision":true},
["b16"],
["b18"],
{"group":""},
["ref"],
{"fixed":true},
["b10"],
{"fixed":false},
["b7"],

##============================================== SOLVED?


data = {
    "b5": {"group": ["group_bouncer_base", "group_bouncer_spring"], "collision": "false", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_RUBBER", "nodeWeight": "1.3", "selfCollision": "true"},
    "b9": {"group": ["group_bouncer_base", "group_bouncer_spring"], "collision": "false", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_RUBBER", "nodeWeight": "1.3", "selfCollision": "true"},
    "b1": {"group": ["group_bouncer_base", "group_bouncer_spring"], "collision": "false", "fixed": "true", "frictionCoef": "1.2", "nodeMaterial": "|NM_RUBBER", "nodeWeight": "2.3", "selfCollision": "true"},
    "b8": {"group": ["group_bouncer_base", "group_bouncer_spring"], "collision": "false", "fixed": "true", "frictionCoef": "1.2", "nodeMaterial": "|NM_RUBBER", "nodeWeight": "2.3", "selfCollision": "true"},
    "b2": {"group": ["group_bouncer_spring", "group_bouncer_top"], "collision": "false", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_PLASTIC", "nodeWeight": "2.3", "selfCollision": "false"},
    "b6": {"group": ["group_bouncer_spring", "group_bouncer_top"], "collision": "false", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_RUBBER", "nodeWeight": "2.3", "selfCollision": "false"},
    "b4": {"group": ["group_bouncer_spring", "group_bouncer_top"], "collision": "false", "fixed": "true", "frictionCoef": "1.2", "nodeMaterial": "|NM_RUBBER", "nodeWeight": "2.3", "selfCollision": "false"},
    "b3": {"group": ["group_bouncer_spring", "group_bouncer_top"], "collision": "true", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_RUBBER", "nodeWeight": "3.5", "selfCollision": "false"},
    "b14": {"group": ["group_bouncer_base"], "collision": "false", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_PLASTIC", "nodeWeight": "3.5", "selfCollision": "false"},
    "b13": {"group": ["group_bouncer_base"], "collision": "true", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_PLASTIC", "nodeWeight": "3.5", "selfCollision": "false"},
    "b12": {"group": ["group_bouncer_base"], "collision": "true", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_RUBBER", "nodeWeight": "3.5", "selfCollision": "false"},
    "b15": {"group": ["group_bouncer_base"], "collision": "true", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_RUBBER", "nodeWeight": "3.5", "selfCollision": "false"},
    "b11": {"group": ["group_bouncer_spring"], "collision": "false", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_PLASTIC", "nodeWeight": "3.5", "selfCollision": "false"},
    "b19": {"group": ["group_bouncer_top"], "collision": "false", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_PLASTIC", "nodeWeight": "3.5", "selfCollision": "false"},
    "b17": {"group": ["group_bouncer_top"], "collision": "false", "fixed": "true", "frictionCoef": "1.2", "nodeMaterial": "|NM_PLASTIC", "nodeWeight": "6.3", "selfCollision": "false"},
    "b16": {"group": ["group_bouncer_top"], "collision": "false", "fixed": "true", "frictionCoef": "1.2", "nodeMaterial": "|NM_PLASTIC", "nodeWeight": "10", "selfCollision": "true"},
    "b18": {"group": ["group_bouncer_top"], "collision": "false", "fixed": "true", "frictionCoef": "1.2", "nodeMaterial": "|NM_PLASTIC", "nodeWeight": "10", "selfCollision": "true"},
    "b7": {"group": [], "collision": "false", "fixed": "false", "frictionCoef": "1.2", "nodeMaterial": "|NM_PLASTIC", "nodeWeight": "10", "selfCollision": "true"},
    "b10": {"group": [], "collision": "false", "fixed": "true", "frictionCoef": "1.2", "nodeMaterial": "|NM_PLASTIC", "nodeWeight": "10", "selfCollision": "true"},
    "ref": {"group": [], "collision": "false", "fixed": "true", "frictionCoef": "1.2", "nodeMaterial": "|NM_PLASTIC", "nodeWeight": "10", "selfCollision": "true"},
}

from collections import defaultdict

def reduce_redundancy(data):
    hierarchy = []
    
    # Initialize a defaultdict to keep track of nodes by each property
    property_dict = defaultdict(list)
    
    # Iterate over the data to group nodes by their properties
    for node, properties in data.items():
        for key, value in properties.items():
            if isinstance(value, list):
                value = tuple(value)  # Use tuple for immutable storage in dictionary
            property_dict[(key, value)].append(node)

    # Start from the bottom of the hierarchy (reverse the order of nodes)
    nodes = list(data.keys())
    nodes.reverse()

    # Track the current hierarchy for each property to avoid redundancy
    current_properties = defaultdict(lambda: None)  # Default value for missing properties is None

    for node in nodes:
        properties = data[node]

        for key, value in properties.items():
            if isinstance(value, list):
                value = tuple(value)  # Convert list to tuple to avoid redundancy in defaultdict
                
            # If the property value has changed, push it up in the hierarchy
            if current_properties[key] != value:
                if current_properties[key] is not None:
                    hierarchy.append({key: current_properties[key]})
                current_properties[key] = value
        
        hierarchy.append([node])  # Append the node itself to the hierarchy

    # Add the last property values
    for key, value in current_properties.items():
        if value is not None:
            hierarchy.append({key: value})

    hierarchy.reverse()  # Reverse to maintain the correct order
    
    return hierarchy


print("START ====")
reduced_hierarchy = reduce_redundancy(data)

for item in reduced_hierarchy:
    print(item)