TODO

Attribute can only be viewed using python when in Object Mode:
bpy.data.meshes['bouncer_1'].attributes['jbeam_node_id'].data[0].value

To view Attributes in Edit Mode:

import bmesh
bm = bmesh.from_edit_mesh(bpy.context.object.data)
v = bm.verts[0]
layer = bm.verts.layers.string.get("jbeam_node_id")
value = v[layer]
v[layer] = f"<new-value>".encode("utf-8")



import bpy
import bmesh


class VertexMonitorOperator(bpy.types.Operator):
    bl_idname = "wm.vertex_monitor"
    bl_label = "Vertex Monitor"
    bl_description = "Monitor selected vertices and update JBeam Node IDs"
    
    _timer = None
    _last_selected_indices = set()
    
    def modal(self, context, event):
        obj = context.object
        if not obj or obj.type != 'MESH' or obj.mode != 'EDIT':
            return {'PASS_THROUGH'}

        if "jbeam_node_id" not in obj.data.attributes:
            return {'PASS_THROUGH'}  # Ignore non-JBeam objects

        if event.type == 'TIMER':
            self.update_vertex_data(context)
        return {'PASS_THROUGH'}
    
    def execute(self, context):
        wm = context.window_manager
        self._timer = wm.event_timer_add(0.1, window=context.window)
        wm.modal_handler_add(self)
        return {'RUNNING_MODAL'}
    
    def force_update_ui(self):
        for area in bpy.context.screen.areas:
            if area.type in {'PROPERTIES', 'VIEW_3D'}:
                for region in area.regions:
                    if region.type in {'WINDOW', 'UI'}:
                        region.tag_redraw()
    
    def update_vertex_data(self, context):
        obj = context.object
        if obj is None or obj.type != 'MESH' or obj.mode != 'EDIT':
            return
        
        bm = bmesh.from_edit_mesh(obj.data)
        bm.verts.ensure_lookup_table()
        selected_verts = [v.index for v in bm.verts if v.select]

        if not selected_verts:
            if self._last_selected_indices:  # Only update if we had a previous selection
                self._last_selected_indices.clear()
                context.scene.active_vertex_idx = -1
                context.scene.jbeam_node_id = ""
                
                self.force_update_ui()
                return
                
        
        # Get active vertex if possible
        active_vert = bm.select_history.active if isinstance(bm.select_history.active, bmesh.types.BMVert) else None
        active_index = active_vert.index if active_vert else (selected_verts[-1] if selected_verts else -1)


        # Only update UI if selection changed
        if set(selected_verts) != self._last_selected_indices:
            self._last_selected_indices = set(selected_verts)
            context.scene.active_vertex_idx = active_index  # Display the active vertex
            
            # Get JBeam IDs for all selected vertices
            layer = bm.verts.layers.string.get("jbeam_node_id")
            if layer:
                jbeam_ids = [bm.verts[v_idx][layer].decode("utf-8") for v_idx in selected_verts if bm.verts[v_idx][layer]]
                context.scene.jbeam_node_id = ", ".join(jbeam_ids)
            else:
                context.scene.jbeam_node_id = ""
            
            self.force_update_ui()
    

class AssignJBeamIDOperator(bpy.types.Operator):
    """Assigns a new JBeam Node ID to the selected vertex"""
    bl_idname = "object.assign_jbeam_id"
    bl_label = "Assign JBeam ID"

    def execute(self, context):
        obj = context.object
        if obj is None or obj.type != 'MESH':
            self.report({'WARNING'}, "No valid mesh object selected")
            return {'CANCELLED'}

        mesh = obj.data
        index = context.scene.active_vertex_idx
        new_value = context.scene.jbeam_node_id.encode("utf-8")

        if obj.mode == 'EDIT':
            bm = bmesh.from_edit_mesh(mesh)
            layer = bm.verts.layers.string.get("jbeam_node_id")
            bm.verts[index][layer] = new_value
            bmesh.update_edit_mesh(mesh)

        self.report({'INFO'}, f"Assigned JBeam Node ID: {context.scene.jbeam_node_id}")
        return {'FINISHED'}

class VertexJBeamEditorPanel(bpy.types.Panel):
    bl_label = "Vertex JBeam Editor"
    bl_idname = "VIEW3D_PT_vertex_jbeam_editor"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = "Tool"

    def draw(self, context):
        layout = self.layout
        scene = context.scene

        layout.operator("wm.vertex_monitor", text="Start Selection Watcher")

        obj = context.object
        mesh = obj.data

        if obj and obj.mode == 'EDIT' and obj.type == 'MESH' and "jbeam_node_id" in obj.data.attributes:
            bm = bmesh.from_edit_mesh(mesh)
            layer = bm.verts.layers.string.get("jbeam_node_id")
            index = scene.active_vertex_idx
            active_node_id = bm.verts[index][layer].decode("utf-8")
            layout.label(text=f"Active Node: {active_node_id} ({index})")
            layout.prop(scene, "jbeam_node_id", text="JBeam Node ID")
            layout.operator("object.assign_jbeam_id", text="Assign JBeam ID")


def register():
    bpy.utils.register_class(VertexMonitorOperator)
    bpy.utils.register_class(VertexJBeamEditorPanel)
    bpy.utils.register_class(AssignJBeamIDOperator)
    bpy.types.Scene.active_vertex_idx = bpy.props.IntProperty(name="Vertex Index", default=-1)
    bpy.types.Scene.jbeam_node_id = bpy.props.StringProperty(name="JBeam Node ID")

def unregister():
    bpy.utils.unregister_class(VertexMonitorOperator)
    bpy.utils.unregister_class(VertexJBeamEditorPanel)
    bpy.utils.unregister_class(AssignJBeamIDOperator)
    del bpy.types.Scene.active_vertex_idx
    del bpy.types.Scene.jbeam_node_id

if __name__ == "__main__":
    register()


==========================================================================

import bpy
import bmesh
import json

class JBeamProperty(bpy.types.PropertyGroup):
    name: bpy.props.StringProperty(name="Property Name")
    value: bpy.props.StringProperty(name="Value")

class AddJBeamPropertyOperator(bpy.types.Operator):
    """Add a new JBeam property"""
    bl_idname = "object.add_jbeam_property"
    bl_label = "Add JBeam Property"

    def execute(self, context):
        context.scene.jbeam_properties.add()
        return {'FINISHED'}

class RemoveJBeamPropertyOperator(bpy.types.Operator):
    """Remove a JBeam property"""
    bl_idname = "object.remove_jbeam_property"
    bl_label = "Remove JBeam Property"

    index: bpy.props.IntProperty()

    def execute(self, context):
        context.scene.jbeam_properties.remove(self.index)
        return {'FINISHED'}

class LoadJBeamPropertiesOperator(bpy.types.Operator):
    """Load properties from selected vertex"""
    bl_idname = "object.load_jbeam_properties"
    bl_label = "Load Properties"

    def execute(self, context):
        obj = bpy.context.object

        # Check if we have a valid object
        if not obj or obj.type != 'MESH' or obj.mode != 'EDIT':
            print("[DEBUG] No valid mesh selected or not in edit mode.")
            self.report({'WARNING'}, "No mesh selected or not in edit mode.")
            return {'CANCELLED'}

        bm = bmesh.from_edit_mesh(obj.data)
        bm.verts.ensure_lookup_table()

        index = bpy.context.scene.get("active_vertex_idx", -1)
        print(f"[DEBUG] Active vertex index: {index}")

        if index < 0 or index >= len(bm.verts):
            print("[DEBUG] Invalid vertex index.")
            self.report({'WARNING'}, "Invalid vertex index.")
            return {'CANCELLED'}

        vert = bm.verts[index]

        # Get JSON property layer
        layer = bm.verts.layers.string.get("jbeam_node_props")
        print(f"[DEBUG] Found jbeam_node_props layer: {layer}")

        if not layer:
            print("[DEBUG] No jbeam_node_props attribute found.")
            self.report({'WARNING'}, "No jbeam_node_props attribute found.")
            return {'CANCELLED'}

        # Load JSON data
        raw_data = vert[layer].decode("utf-8") if vert[layer] else "{}"
        print(f"[DEBUG] Extracted JSON data: {raw_data}")

        try:
            prop_dict = json.loads(raw_data)
        except json.JSONDecodeError:
            print("[DEBUG] Invalid JSON format.")
            self.report({'ERROR'}, "Invalid JSON format in vertex data.")
            return {'CANCELLED'}

        print(f"[DEBUG] Parsed properties: {prop_dict}")

        # Clear existing properties in UI
        context.scene.jbeam_properties.clear()

        # Populate UI with extracted properties
        for name, value in prop_dict.items():
            prop = context.scene.jbeam_properties.add()
            prop.name = name
            prop.value = str(value)  # Ensure it's a string
            print(f"[DEBUG] Added property to UI: {name} = {value}")

        bpy.context.area.tag_redraw()
        self.report({'INFO'}, f"Loaded {len(prop_dict)} properties.")
        return {'FINISHED'}

class SaveJBeamPropertiesOperator(bpy.types.Operator):
    """Save properties to all selected vertices"""
    bl_idname = "object.save_jbeam_properties"
    bl_label = "Save Properties"

    def execute(self, context):
        obj = bpy.context.object

        if not obj or obj.type != 'MESH' or obj.mode != 'EDIT':
            self.report({'WARNING'}, "No mesh selected or not in edit mode.")
            return {'CANCELLED'}

        bm = bmesh.from_edit_mesh(obj.data)
        bm.verts.ensure_lookup_table()

        # Get selected vertices
        selected_verts = [v for v in bm.verts if v.select]
        if not selected_verts:
            self.report({'WARNING'}, "No vertices selected.")
            return {'CANCELLED'}

        # Get or create JSON property layer
        layer = bm.verts.layers.string.get("jbeam_node_props")
        if not layer:
            layer = bm.verts.layers.string.new("jbeam_node_props")

        # Convert UI properties to JSON
        prop_dict = {prop.name: prop.value for prop in context.scene.jbeam_properties}
        json_data = json.dumps(prop_dict)

        # Assign JSON to all selected vertices
        for vert in selected_verts:
            vert[layer] = json_data.encode("utf-8")

        bmesh.update_edit_mesh(obj.data)

        self.report({'INFO'}, f"Properties saved for {len(selected_verts)} vertices.")
        return {'FINISHED'}


class JBeamPropertiesPanel(bpy.types.Panel):
    """Panel for JBeam Properties"""
    bl_label = "JBeam Properties"
    bl_idname = "VIEW3D_PT_jbeam_properties"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = "Tool"

    def draw(self, context):
        layout = self.layout
        scene = context.scene

        row = layout.row()
        row.operator("object.load_jbeam_properties", text="Load Properties")

        for i, prop in enumerate(scene.jbeam_properties):
            row = layout.row()
            row.prop(prop, "name", text="")
            row.prop(prop, "value", text="")
            remove_op = row.operator("object.remove_jbeam_property", text="X")
            remove_op.index = i

        layout.operator("object.add_jbeam_property", text="Add Property")
        layout.operator("object.save_jbeam_properties", text="Save Properties")

def register():
    bpy.utils.register_class(JBeamProperty)
    bpy.utils.register_class(AddJBeamPropertyOperator)
    bpy.utils.register_class(RemoveJBeamPropertyOperator)
    bpy.utils.register_class(LoadJBeamPropertiesOperator)
    bpy.utils.register_class(SaveJBeamPropertiesOperator)
    bpy.utils.register_class(JBeamPropertiesPanel)
    bpy.types.Scene.jbeam_properties = bpy.props.CollectionProperty(type=JBeamProperty)
    bpy.types.Scene.active_vertex_idx = bpy.props.IntProperty(default=-1)

def unregister():
    bpy.utils.unregister_class(JBeamProperty)
    bpy.utils.unregister_class(AddJBeamPropertyOperator)
    bpy.utils.unregister_class(RemoveJBeamPropertyOperator)
    bpy.utils.unregister_class(LoadJBeamPropertiesOperator)
    bpy.utils.unregister_class(SaveJBeamPropertiesOperator)
    bpy.utils.unregister_class(JBeamPropertiesPanel)
    del bpy.types.Scene.jbeam_properties
    del bpy.types.Scene.active_vertex_idx

if __name__ == "__main__":
    register()
